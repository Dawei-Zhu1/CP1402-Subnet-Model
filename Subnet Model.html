<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="author" content="Dawei Zhu">
	<title>Subnet Example</title>
</head>
<style>
    /* * {
        padding: 0;
        margin: 0;
    } */
	html{
		font-family: 'Courier New', Courier, monospace;
	}
	/* #ipv4{
		font-size: 0px;text-align: center;
	} */
	#ipv4 span{
		font-size: 24px;
		display: inline-flex;
	}
	.subnet_class_bits {
		color:burlywood;
		font-weight: lighter;
		background-color:darkmagenta;
	}
	.subnet_bits {
		color: red;
		background-color: lightgreen;
	}
	.host_bits {
		color: blueviolet;
		font-weight: bold;
		background-color: gold;
	}
	#subnet_mask{
		font-size: 24px;

	}
</style>
<body>
	<div id = "container">
		<h1>Subnet Example</h1>
		<div id="example">
			<div id="help">
				<h2>Help</h2>
				You may use <u>keyboard shortcuts</u> to move these boundaries:<br />
				<strong>&lArr;</strong>: move custom subnet boundary left;<br />
				<strong>&rArr;</strong>: move custom subnet boundary right;<br />
				<strong>Q</strong>: move provided subnet boundary left ;<br />
				<strong>D</strong>: move custom subnet boundary right;<br />
				By Dawei Zhu
			</div>
			<h2>IP</h2>
			<div id="ipv4">
				<div id="ip_dec">
					<span>In dec: </span>
					<br />
					<span class="octet"></span>
					<span class="ip_seperator">.</span>

					<span class="octet"></span>
					<span class="ip_seperator">.</span>

					<span class="octet"></span>
					<span class="ip_seperator">.</span>

					<span class="octet"></span>
					<span class="slashed_mask"></span> 
				</div>
				<div id="ip_bin">
					<span>In bin: </span>
					<br />
					<span class="host_bits">
						<span class="subnet_bits">
							<span class="subnet_class_bits">
					<span class="octet subnet_class_bits"></span>
							</span>
					<span class="octet subnet_bits"></span>
						</span>
					<span class="octet host_bits"></span>
					</span>

					<span class="slashed_mask"></span>

				</div>
				<div id='dashboard'>
					<div id="info">
						<h2>Subnet Info</h2>
						<div id="subnet_mask">
							<div id="mask_dec"><span></span><span class="slashed_mask"></span></div>
							<div id="mask_bin"><span></span><span class="slashed_mask"></span></div>
							
						</div>
						
					</div>
					<menu id="console">
						<div>
							<label for="subnet_type"></label>
							<input type="button" name="subnet_type" value="&lt;&lt;" onclick="ip.to_the_most_left_subnet_boundary();draw(ip)">
							<input type="button" name="subnet_type" value="&lt;" onclick="ip.subnet_boundary_shift_left();draw(ip)">
                            <span>Subnet</span>
							<input type="button" name="subnet_type" value="&gt;" onclick="ip.subnet_boundary_shift_right(),draw(ip)">
							<input type="button" name="subnet_type" value="&gt;&gt;" onclick="ip.to_the_most_right_subnet_boundary(),draw(ip)">

						</div>
						<div>
							<label for="subnet_type"></label>
							<input type="button" name="subnet_type" value="&lt;&lt;" onclick="ip.to_the_most_left_provided_boundary();draw(ip)">
							<input type="button" name="subnet_type" value="&lt;" onclick="ip.provided_boundary_shift_left();draw(ip)">
							<span>Provider Subnet</span>
							<input type="button" name="subnet_type" value=" &gt;" onclick="ip.provided_boundary_shift_right();draw(ip)">
							<input type="button" name="subnet_type" value="&gt;&gt;" onclick="ip.to_the_most_right_provided_boundary();draw(ip)">
						</div>
					</menu>
				</div>
				
			</div>
		</div>
	</div>
</body>

<script type="text/javascript">
	const IP_OCTET_QTY = 4,
	IP_BEGIN_INDEX = 0,
	IP_MAX_BITS = 32,
	OCTET_BITS = 8,
	LEAST_SUBNET_BITS = 2

	var ip = {
		bin: null,
		class_bit_number: 16,
		subnet_bit_number: 8,
		host_bit_number: 8,
		__initialise__: function (){
			this.bin = generateBinIp()
		},
		subnet_boundary_shift_left: function () {
			if (this.subnet_bit_number > 0){
				this.subnet_bit_number --
				this.host_bit_number ++
			}
		},
		subnet_boundary_shift_right: function () {
			if (this.host_bit_number > 2){
				this.subnet_bit_number ++
				this.host_bit_number --
			}
		},
		provided_boundary_shift_left: function () {
			if (this.class_bit_number > 0){
				this.class_bit_number --
				this.subnet_bit_number ++
			}
		},
		provided_boundary_shift_right: function () {
			if (this.subnet_bit_number > 0){
				this.class_bit_number ++
				this.subnet_bit_number --
			}
		},
		to_the_most_left_subnet_boundary: function(){
			while(this.subnet_bit_number > 0) {
				this.subnet_boundary_shift_left()
			}
		},
		to_the_most_right_subnet_boundary: function(){
			while(this.subnet_bit_number > LEAST_SUBNET_BITS){
				this.subnet_boundary_shift_right()
			}
		},
		to_the_most_left_provided_boundary: function(){
			while(this.class_bit_number > 0) {
				this.provided_boundary_shift_left()
			}
		},
		to_the_most_right_provided_boundary: function(){
			while(this.subnet_bit_number > 0){
				this.provided_boundary_shift_right()
			}
		},
		get_subnet_mask: function () {
			let subnet_mask ='0'.repeat(this.host_bit_number).padStart(32,'1')
			return bin32_to_4_octets(subnet_mask)
		},
		slice_by_boundaries: function(dotted_bin){
			/* 
			Return an array of 3 components, sliced by 2 boundaries
			<div id="whole">
				<div id="subnet">
					<div id="provided">
					</div>
				</div>
			</div>
			 */
			let formatted_bin = dotted_bin
			let provided_network_bits = formatted_bin.slice(
				0, 
				index_offset_with_formatted_ip(this.class_bit_number)
			)
			let subnet_network_bits = formatted_bin.slice(
				index_offset_with_formatted_ip(this.class_bit_number), 
				index_offset_with_formatted_ip(this.get_subnet_bits())
			)
			let host_bits = formatted_bin.slice(
				index_offset_with_formatted_ip(this.get_subnet_bits())
			)
			return [provided_network_bits, subnet_network_bits, host_bits]
		},
		get_sliced_dotted_bin_ip: function () {
			return this.slice_by_boundaries(this.to_dotted_bin())
		},
		to_bin_array: function(){
			/* Return an array of 4 numbers */
			return bin32_to_4_octets(this.bin)
		},
		to_dec_array: function(){
			/* IP in dec, in a 4-part array */
			return stringBinToIntIp(bin32_to_4_octets(this.bin))
		},
		to_dotted_bin: function(){
			/* Return a string repr bin octet, separated by dot */
			return this.to_bin_array().join(".")
		},
		to_dotted_dec: function () {
			return this.to_dec_array().join(".")
		},
		get_subnet_bits: function() {
			/* The sum of class bits number and subnet capacity */
			return this.class_bit_number + this.subnet_bit_number
		},
		show: function () {
			/* Debug */
			console.log(
			`IP: ${this.to_dotted_bin()};
Dec: ${this.to_dec_array()};
Class: ${this.class_bit_number};
Subnet cap: ${this.subnet_bit_number};
Host cap: ${this.host_bit_number};
Subnet Mask: ${this.get_subnet_mask()};
Sliced bin IP: 
	${this.get_sliced_dotted_bin_ip()[0]}
	${this.get_sliced_dotted_bin_ip()[1]}
	${this.get_sliced_dotted_bin_ip()[2]}`)
		}
	}
	ip.__initialise__()
	draw(ip)

	document.addEventListener('keydown', 
		(event)=>{
			var keyname = event.key,
			keycode = event.code
			event.preventDefault()
			// Single key
			if (keyname == 'ArrowLeft'){
				ip.subnet_boundary_shift_left()
			}
			if (keyname == 'ArrowRight'){
				ip.subnet_boundary_shift_right()
			}
			if (keyname == 'a'){
				ip.provided_boundary_shift_left()
			}
			if (keyname == 'd'){
				ip.provided_boundary_shift_right()
			}
			// Ctrl + keyName
			if ((event.ctrlKey || event.metaKey) && event.key === 'ArrowLeft') {
				ip.to_the_most_left_subnet_boundary()
			}
			if ((event.ctrlKey || event.metaKey) && event.key === 'ArrowRight') {
				ip.to_the_most_right_subnet_boundary()
			}
			if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
				ip.to_the_most_left_provided_boundary()
			}
			if ((event.ctrlKey || event.metaKey) && event.key === 'd') {
				ip.to_the_most_right_provided_boundary()
			}
			ip.show()
			draw(ip)
		}
	)	


	function draw(ip){
		
		// // var subnet_mask = subnet_class_bit_number + subnet_bit_number
		// let subnet_mask = '0'.repeat(host_bit_number).padStart(32,'1'),
		// subnet_mask_octets = [];
		// subnet_mask_decimal = []
		

		// for (let i = 0; i < IP_MAX_BITS/OCTET_BITS; i++){
		// 	subnet_mask_octets.push(subnet_mask.slice(
		// 	OCTET_BITS * i, 
		// 	OCTET_BITS * i + OCTET_BITS))
			
		// }

		// for (let each of subnet_mask_octets){
		// 	subnet_mask_decimal.push(parseInt(each, 2))
		// }
		
		// document.getElementById("mask_bin").firstChild.innerText = subnet_mask_octets.join('.')
		// document.getElementById("mask_dec").firstChild.innerText = subnet_mask_decimal.join('.')


		// var formatted_full_bin_ip = ip_bin.join('.')

		// var subnet_class_bits = formatted_full_bin_ip.slice(
		// 	IP_BEGIN_INDEX, 
		// 	index_offset_with_formatted_ip(subnet_class_bit_number)
		// ),
		// subnet_bits = formatted_full_bin_ip.slice(
		// 	index_offset_with_formatted_ip(subnet_class_bit_number), 
		// 	index_offset_with_formatted_ip(subnet_class_bit_number + subnet_bit_number)
		// )

		// host_bits = formatted_full_bin_ip.slice( index_offset_with_formatted_ip(IP_MAX_BITS - host_bit_number))

		// var full_bin_ip = [subnet_class_bits, subnet_bits, host_bits]
		// 	// insert binary ip into html
		// for (let [index, each_part] of full_bin_ip.entries()){
		// 	document.getElementById("ip_bin").getElementsByClassName("octet")[index].innerText = each_part
		// }

		// insert decimal ip into html
		for (let [index, octet] of ip.to_dec_array().entries()){
			document.getElementById("ip_dec").getElementsByClassName("octet")[index].innerText = octet.toString()
		}
		// insert 3-fregment binary 
		for ([index, fragment] of ip.get_sliced_dotted_bin_ip().entries()){
			document.getElementById("ip_bin").getElementsByClassName("octet")[index].innerText = fragment
		}
		
		// This is for / xx (slash).
		for (let i = 0; i < document.getElementsByClassName("slashed_mask").length; i++){
			document.getElementsByClassName("slashed_mask")[i].innerText = '/ ' + ip.get_subnet_bits().toString()
		}
	}



	function generate_random(min, max){
		/* Generate a random number. */
		let random_number = Math.random() * (max - min) + min;
		return Math.floor(random_number)
	}

	// function 
	function generate_ip_in_dec(){
		/* Generate 4 octets of IP addr. */
		let _ip_octets = []
		for (let i = 0; i < IP_OCTET_QTY; i++){
			let octet_value = generate_random(0x00, 0xff)
			_ip_octets.push(octet_value)
		}
		return _ip_octets
	}

	function generateBinIp(){
		/* Generate 32 binary ip in string */
		let _ip_octets = ""
		for (let i = 0; i < IP_OCTET_QTY; i++){
			let octet_value = generate_random(0x00, 0xff)
			_ip_octets+=octet_value.toString(2).padStart(OCTET_BITS, "0")
		}
		return _ip_octets
	}

	function binToDecNum(int_str){
		/* String binary to decimal number */
		return parseInt(int_str, 2)
	}
	function bin32_to_4_octets(bin_32){
		/* Devide 32 bit bin-in-str to 4 octets */
		let result = []
		for (let i = 0; i < IP_OCTET_QTY; i++){
			let octet_bin = bin_32.slice(i * OCTET_BITS, (i + 1) * OCTET_BITS)
			result.push(octet_bin)
		}
		return result
	}
	function stringBinToIntIp(four_octets){
		/* Convert literal bin ip to decimal ip */
		let result = []
		for (octet of four_octets){
			result.push(binToDecNum(octet))
		}
		return result
	}
	function convert_to_8bits_bin(ip_blocks){
		let _ip_binary_octets = []
		for (let each_octet of ip_blocks){
			_ip_binary_octets.push(each_octet.toString(2).padStart(OCTET_BITS, "0"))
		}
		return _ip_binary_octets
	}

	function insert_at_index(text, insertion, index){
		/* Insert after index. */
		let _text = text
		let _index_offset = 1
		let _index = index + _index_offset
		return text.slice(0, _index) + insertion + text.slice(_index)
	}


	function index_offset_with_formatted_ip(formatted_bin_ip_index){
		/* 
		Deal with 32bit+dots format ip, skip these dots
		Make sure the boundary are created within these indeces:
		0~7, 9~16, 18~25, 27~34
		0 -> 0 * 8 + 0
		8 -> 9 = 1 * 8 + 1
		16 -> 18 = 2 * 8 + 2
		24 -> 27 = 3 * 8 + 3
		n -> n * 8 + n = 9n
		*/
		return formatted_bin_ip_index + Math.floor(formatted_bin_ip_index/OCTET_BITS)
	}

</script>
</html>